import {
  core.control {discard},
  core.magic,
  core.memory {load-int, store-int},
  core.rune {load-rune},
  core.rune.entity,
  core.text {_get-content-pointer, _get-rune, _take-N, format, singleton},
  core.text.entity,
  noa.gen.pairs {pairs},
  noa.gen.texts {texts},
  noa.suite {noa},
  this.error {Error, error},
  this.parser {parser, return, zonk},
  this.pos {Pos, pos},
  this.state {State, new-state, state},
}

define _read<a>(ch: &cell(a)): &a {
  let ch = core.magic.cast(&cell(a), int, ch) in
  let val-base = load-int(ch) in
  core.magic.cast(int, &a, val-base)
}

define get-position(st-ref: &cell(state)): pos {
  tie State of {lastpos = Pos of {row, column}} = _read(st-ref) in
  Pos of {row = *row, column = *column}
}

inline _proceed(st-ref: &cell(state), byte-offset: int, new-pos: pos): unit {
  mutate(st-ref, function (st) {
    let State of {stream, lastpos = Pos of {}} = st in
    State of {
      stream = core.text._drop(byte-offset, stream),
      lastpos = new-pos,
    }
  })
}

constant _newline: rune {
  0x0a
}

inline _get-new-pos(r: rune, row: int, column: int): pos {
  if core.rune.entity.as-entity::identity(r, _newline) {
    Pos of {row = add-int(row, 1), column = 0}
  } else {
    Pos of {row, column = add-int(column, 1)}
  }
}

define end-of-input(): parser(unit) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let len = core.text.text-byte-length(stream) in
    if eq-int(len, 0) {
      Pass(Unit)
    } else {
      let r = _get-rune(stream, 0) in
      Fail(Error(
        format(
          "unexpected character: {}, expecting: end of input",
          [singleton(r)],
        ),
        Pos(*row, *column),
      ))
    }
  }
}

define satisfy(p: (rune) -> bool): parser(rune) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let len = core.text.text-byte-length(stream) in
    if eq-int(len, 0) {
      Fail(Error(*"unexpected end of input", Pos(*row, *column)))
    } else {
      let r = _get-rune(stream, 0) in
      if p(r) {
        let new-pos = _get-new-pos(r, *row, *column) in
        let offset = core.rune.size(r) in
        _proceed(st-ref, offset, new-pos);
        Pass(r)
      } else {
        Fail(Error(format("`satisfy` against {} failed", [singleton(r)]), Pos(*row, *column)))
      }
    }
  }
}

define chunk(t: &text): parser(unit) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let len1 = core.text.text-byte-length(stream) in
    let len2 = core.text.text-byte-length(t) in
    if lt-int(len1, len2) {
      Fail(Error(*"unexpected end of input", Pos(*row, *column)))
    } else {
      let ptr1 = _get-content-pointer(stream) in
      let ptr2 = _get-content-pointer(t) in
      let f =
        define consumer(index: int, row: int, column: int): except(error, unit) {
          if eq-int(index, len2) {
            _proceed(st-ref, len2, Pos of {row, column});
            Pass(Unit)
          } else {
            let rune1 = load-rune(add-int(ptr1, index)) in
            let rune2 = load-rune(add-int(ptr2, index)) in
            if core.rune.entity.as-entity::identity(rune1, rune2) {
              let offset = core.rune.size(rune1) in
              let Pos of {row, column} = _get-new-pos(rune1, row, column) in
              consumer(add-int(index, offset), row, column)
            } else {
              Fail(Error(
                format(
                  "unexpected character: {}, expecting: {}",
                  [singleton(rune1), singleton(rune2)],
                ),
                Pos(row, column),
              ))
            }
          }
        }
      in
      f(0, *row, *column)
    }
  }
}

inline take-while(p: (rune) -> bool): parser(text) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let len = core.text.text-byte-length(stream) in
    if eq-int(len, 0) {
      Pass(*stream)
    } else {
      let ptr1 = _get-content-pointer(stream) in
      let f =
        define consumer(index: int, row: int, column: int): text {
          let r = load-rune(add-int(ptr1, index)) in
          if p(r) {
            let offset = core.rune.size(r) in
            let Pos of {row, column} = _get-new-pos(r, row, column) in
            consumer(add-int(index, offset), row, column)
          } else {
            let result = _take-N(index, stream) in
            _proceed(st-ref, index, Pos of {row, column});
            result
          }
        }
      in
      Pass(f(0, *row, *column))
    }
  }
}

inline drop-while(p: (rune) -> bool): parser(unit) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let len = core.text.text-byte-length(stream) in
    if eq-int(len, 0) {
      Pass(Unit)
    } else {
      let ptr1 = _get-content-pointer(stream) in
      let f =
        define consumer(index: int, row: int, column: int): unit {
          let r = load-rune(add-int(ptr1, index)) in
          if p(r) {
            let offset = core.rune.size(r) in
            let Pos of {row, column} = _get-new-pos(r, row, column) in
            consumer(add-int(index, offset), row, column)
          } else {
            _proceed(st-ref, index, Pos of {row, column});
            Unit
          }
        }
      in
      f(0, *row, *column);
      Pass(Unit)
    }
  }
}

define _load-text-offset(t: &text): int {
  load-int(magic cast(&text, int, t))
}

define _rewind(t: text, new-from: int): text {
  let from-ptr = core.magic.cast(text, int, t) in
  store-int(new-from, from-ptr);
  core.magic.cast(int, text, from-ptr)
}

define _rewind-state(base-offset: int, row: int, column: int): (state) -> state {
  function (st: state) {
    let State of {stream, lastpos = Pos of {}} = st in
    let new-stream = _rewind(stream, base-offset) in
    State of {stream = new-stream, lastpos = Pos of {row, column}}
  }
}

define attempt<a>(p: parser(a)): parser(a) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let base-offset = _load-text-offset(stream) in
    match p(st-ref) {
    | Pass(result) =>
      Pass(result)
    | Fail(e) =>
      mutate(st-ref, _rewind-state(base-offset, *row, *column));
      Fail(e)
    }
  }
}

// co-attempt
define look-ahead<a>(p: parser(a)): parser(a) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let base-offset = _load-text-offset(stream) in
    match p(st-ref) {
    | Pass(result) =>
      mutate(st-ref, _rewind-state(base-offset, *row, *column));
      Pass(result)
    | Fail(e) =>
      Fail(e)
    }
  }
}

inline choice<a>(p1: parser(a), p2: parser(a)): parser(a) {
  function (st-ref: &cell(state)) {
    match p1(st-ref) {
    | Pass(result) =>
      Pass(result)
    | Fail(_) =>
      p2(st-ref)
    }
  }
}

define select<a>(p: parser(a), ps: list(parser(a))): parser(a) {
  function (st-ref: &cell(state)) {
    match p(st-ref) {
    | Pass(result) =>
      Pass(result)
    | Fail(e) =>
      match ps {
      | Nil =>
        Fail(e)
      | Cons(alt, rest) =>
        select(alt, rest)(st-ref)
      }
    }
  }
}

inline many<a>(p: parser(a)): parser(list(a)) {
  define self(st-ref: &cell(state)) {
    match p(st-ref) {
    | Pass(v) =>
      try vs = self(st-ref) in
      Pass(Cons(v, vs))
    | Fail(_) =>
      Pass([])
    }
  }
}

inline some<a>(p: parser(a)): parser(list(a)) {
  function (st-ref: &cell(state)) {
    try v = p(st-ref) in
    try vs = many(p)(st-ref) in
    Pass(Cons(v, vs))
  }
}

inline some-with<a>(p: parser(a)): parser(list(a)) {
  with zonk {
    bind v = p in
    bind vs = many(p) in
    return(Cons(v, vs))
  }
}

define zen(): unit {
  noa::check(
    "chunk(t1) against append(t1, t2) must succeed and the remaining text is t2",
    pairs(texts, texts),
    function (p) {
      let Pair(t1, t2) = p in
      let full-text on t1, t2 = core.text.append(t1, t2) in
      let st = new-state(full-text) in
      let parse-result on t1, st =
        let p = chunk(t1) in
        let parse-result = p(st) in
        parse-result
      in
      discard(t1);
      match parse-result {
      | Pass(_) =>
        let result on t2, st =
          tie State of {stream} = _read(st) in
          core.text.entity.as-entity::identity(t2, stream)
        in
        discard(t2);
        discard(st);
        result
      | Fail(_) =>
        False
      }
    },
  );
  let is-h =
    function (r) {
      core.rune.entity.as-entity::identity(r, 0x68)
    }
  in
  let newline-p =
    function (r) {
      core.rune.entity.as-entity::identity(r, 0x0a)
    }
  in
  let st = new-state(*"hehehe") in
  let many-he = many(chunk("he")) in
  let hey-or-hel =
    choice(
      chunk("aoeu"),
      chunk("helã‚"),
    )
  in
  // let p = satisfy(newline-p) in
  // let until-newline =
  //   take-while(function (r) {
  //     not(core.rune.entity.as-entity::identity(r, 0x0a))
  //   })
  // in
  // let skip-until-newline =
  //   drop-while(function (r) {
  //     not(core.rune.entity.as-entity::identity(r, 0x0a))
  //   })
  // in
  // let result on st = many-he(st) in
  let result on st = end-of-input()(st) in
  // let result on st = hey-or-hel(st) in
  // let result on st = skip-until-newline(st) in
  // let p2 = chunk(", wo\nrld") in
  // let result on st = p2(st) in
  match result {
  | Pass(_) =>
    let _ on st =
      tie State of {stream, lastpos = Pos of {row, column}} = _read(st) in
      print("remaining text: ");
      print(stream);
      print("\n");
      printf("0-indexed cursor position: ({}, {})\n", [%ld(*row), %ld(*column)])
    in
    let _ = st in
    print("pass!\n")
  | Fail(Error(content, _)) =>
    printf("fail: {}\n", [content])
  }
}
