import {
  core.box {axiom-T},
  core.int {max-int},
  core.magic,
  core.memory {load-int, store-int},
  core.ref {borrow, mutate, ref},
  core.rune,
  this.zonk-kit {_Position, _Zonk-Kit, position, zonk-kit},
}

define _unsafe-read<a>(ch: &ref(a)): &a {
  let ch = core.magic.cast(&ref(a), pointer, ch);
  let val-base = load-int(ch);
  core.magic.cast(int, &a, val-base)
}

inline _unsafe-mutate<a>(ch: &ref(a), f: (a) -> a): unit {
  let ch = core.magic.cast(&ref(a), pointer, ch);
  let val-base = load-int(ch);
  let current-value = core.magic.cast(int, a, val-base);
  let new-value = f(current-value);
  store-int(core.magic.cast(a, int, new-value), ch)
}

inline _set-gap-size<c>(k: &zonk-kit(c), new-gap-size: int): unit {
  tie _Zonk-Kit of {position-ref} = k;
  _unsafe-mutate(position-ref, function (position) {
    let _Position of {cursor, line, column, gap-size} = position;
    _Position of {cursor, line, column, gap-size := max-int(gap-size, new-gap-size)}
  })
}

define _get-cursor<c>(k: &zonk-kit(c)): int {
  tie _Zonk-Kit of {position-ref} = k;
  let position = _unsafe-read(position-ref);
  tie _Position of {cursor} = position;
  *cursor
}

define _get-gap-size<c>(k: &zonk-kit(c)): int {
  tie _Zonk-Kit of {position-ref} = k;
  borrow(position-ref, function (position) {
    tie _Position of {gap-size} = position;
    quote {*gap-size}
  })
}

define _get-line<c>(k: &zonk-kit(c)): int {
  tie _Zonk-Kit of {position-ref} = k;
  borrow(position-ref, function (position) {
    tie _Position of {line} = position;
    quote {*line}
  })
}

define _get-column<c>(k: &zonk-kit(c)): int {
  tie _Zonk-Kit of {position-ref} = k;
  borrow(position-ref, function (position) {
    tie _Position of {column} = position;
    quote {*column}
  })
}

inline _set-new-position<c>(k: &zonk-kit(c), cursor: int, line: int, column: int): unit {
  tie _Zonk-Kit of {position-ref} = k;
  mutate(position-ref, function (position) {
    let _Position of {gap-size} = axiom-T(position);
    quote {_Position of {cursor, line, column, gap-size}}
  })
}

inline _proceed-by-rune<c>(k: &zonk-kit(c), r: rune): unit {
  tie _Zonk-Kit of {position-ref} = k;
  mutate(position-ref, function (position) {
    let _Position of {cursor, line, column, gap-size} = axiom-T(position);
    if eq-rune(r, `\n`) {
      let cursor = add-int(cursor, 1);
      let line = add-int(line, 1);
      let column = 0;
      quote {_Position of {cursor, line, column, gap-size}}
    } else {
      let cursor = add-int(cursor, core.rune.size(r));
      let column = add-int(column, 1);
      quote {_Position of {cursor, line, column, gap-size}}
    }
  })
}

inline _export-state<c>(k: &zonk-kit(c)): position {
  tie _Zonk-Kit of {position-ref} = k;
  core.ref.clone(position-ref)
}

inline _import-state<c>(k: &zonk-kit(c), new-position: position): unit {
  tie _Zonk-Kit of {position-ref} = k;
  mutate(position-ref, function (old-position) {
    let _Position of {} = axiom-T(old-position);
    quote {new-position}
  })
}
