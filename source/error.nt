import {
  core.external {malloc},
  core.int {max-int},
  core.int8-array {_copy-int8-array},
  core.list {is-empty},
  core.magic,
  core.memory {store-int},
  core.text {format, intercalate, singleton, take-N, text-byte-length},
  core.text.show {show-text, show-text-N},
  core.word,
  this.pos {Pos, pos},
}

data observation {
| Rune(rune)
| Range(from: int, size: int, stream: &text)
| Text(text)
| Text-N(&text)
| Label(text)
| End-Of-Input
}

define _observation-size(o: &observation): int {
  case o {
  | Rune(r) =>
    core.rune.size(*r)
  | Range(_, size, _) =>
    *size
  | Text(t) =>
    text-byte-length(t)
  | Text-N(t) =>
    text-byte-length(*t)
  | Label(_) =>
    0
  | End-Of-Input =>
    0
  }
}

define _max-obserwation(o1: observation, o2: observation): observation {
  let s1 on o1 = _observation-size(o1) in
  let s2 on o2 = _observation-size(o2) in
  if gt-int(s1, s2) {
    o1
  } else {
    o2
  }
}

data _error {
| _Error(
    found: int,
    expected: list(observation),
  )
}

constant error: tau {
  () -> _error
}

define unexpected-end-of-input(): error {
  function () {
    _Error of {found = 0, expected = []}
  }
}

define _unsafe-slice-N-absolute(start: int, size: int, t: &text): text {
  let start = max-int(start, 0) in
  let size = max-int(size, 0) in
  let ptr = core.magic.cast(&text, int, t) in
  let u = core.word.size in
  let content-ptr = add-int(ptr, add-int(mul-int(u, 2), start)) in
  let new-ptr = malloc(add-int(size, mul-int(u, 2))) in
  store-int(0, new-ptr);
  store-int(size, add-int(new-ptr, u));
  let new-content-ptr = add-int(new-ptr, mul-int(u, 2)) in
  _copy-int8-array(content-ptr, new-content-ptr, 0, size);
  core.magic.cast(int, text, new-ptr)
}

define show-observation(o: observation): text {
  match o {
  | Rune(r) =>
    show-text(singleton(r))
  | Range(from, len, stream) =>
    show-text(_unsafe-slice-N-absolute(from, len, stream))
  | Text(t) =>
    show-text(t)
  | Text-N(t) =>
    show-text-N(t)
  | Label(l) =>
    l
  | End-Of-Input =>
    *"end of input"
  }
}

define show-found(size: int, stream: &text): text {
  show-text(take-N(size, stream))
}

define show-position(p: pos): text {
  let Pos of {row, column} = p in
  format("row {}, column {}", [%ld(add-int(row, 1)), %ld(add-int(column, 1))])
}

define set-expected(o: observation, e: error): error {
  function () {
    match e() {
    | _Error of {found} =>
      _Error of {found, expected = [o]}
    }
  }
}

inline join(e1: error, e2: error): error {
  function () {
    match e1(), e2() {
    | _Error(found1, expected1), _Error(found2, expected2) =>
      _Error(max-int(found1, found2), append(expected1, expected2))
    }
  }
}

define report(e: error, position: pos, stream: &text): text {
  match e() {
  | _Error of {found, expected} =>
    let position' = show-position(position) in
    let b on expected = is-empty(expected) in
    if b {
      format("parse error at {}:\nunexpected:\n  {}", [position', show-found(found, stream)])
    } else {
      let expected' = intercalate(*", ", map(show-observation, expected)) in
      format("parse error at {}:\nexpected:\n  {}\nfound:\n  {}", [position', expected', show-found(found, stream)])
    }
  }
}
