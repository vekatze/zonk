import {
  core.control {loop},
  core.rune {load-rune},
  core.rune.entity,
  core.text {_get-content-pointer, _get-rune, _take-N, is-empty, take-N, text-byte-length},
  core.text.entity,
  noa.gen.pairs {pairs},
  noa.gen.texts {texts},
  noa.suite {noa},
  this.error {
    End-Of-Input,
    Label,
    Range,
    Rune,
    Text,
    Text-N,
    _Error,
    error,
    join,
    set-expected,
    unexpected-end-of-input,
  },
  this.internal {_get-new-pos, _load-text-offset, _proceed, _read, _rewind-state},
  this.pos {Pos, pos},
  this.state {State, new-state, state},
}

inline parser(a: tau): tau {
  (input: &cell(state)) -> except(error, a)
}

define get-position(st-ref: &cell(state)): pos {
  tie State of {lastpos = Pos of {row, column}} = _read(st-ref) in
  Pos of {row = *row, column = *column}
}

constant end-of-input: parser(unit) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let len = core.text.text-byte-length(stream) in
    if eq-int(len, 0) {
      Pass(Unit)
    } else {
      let r = _get-rune(stream, 0) in
      Fail(function () {
        _Error of {
          found = Rune(r),
          expected = [End-Of-Input],
          position = Pos(*row, *column),
        }
      })
    }
  }
}

inline satisfy(p: (rune) -> bool): parser(rune) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let len = core.text.text-byte-length(stream) in
    if eq-int(len, 0) {
      Fail(unexpected-end-of-input(Pos(*row, *column)))
    } else {
      let r = _get-rune(stream, 0) in
      if p(r) {
        let new-pos = _get-new-pos(r, *row, *column) in
        let offset = core.rune.size(r) in
        _proceed(st-ref, offset, new-pos);
        Pass(r)
      } else {
        Fail(function () {
          _Error of {
            found = Rune(r),
            expected = [],
            position = Pos(*row, *column),
          }
        })
      }
    }
  }
}

constant any-rune: parser(rune) {
  satisfy(function (_) {
    True
  })
}

inline chunk(t: &text): parser(unit) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row = orig-row, column = orig-column}} = _read(st-ref) in
    let base-offset = _load-text-offset(stream) in
    let len1 = core.text.text-byte-length(stream) in
    let len2 = core.text.text-byte-length(t) in
    if lt-int(len1, len2) {
      Fail(unexpected-end-of-input(Pos(*orig-row, *orig-column)))
    } else {
      let ptr1 = _get-content-pointer(stream) in
      let ptr2 = _get-content-pointer(t) in
      let f =
        define consumer(index: int, row: int, column: int): except(error, unit) {
          if eq-int(index, len2) {
            _proceed(st-ref, len2, Pos of {row, column});
            Pass(Unit)
          } else {
            let rune1 = load-rune(add-int(ptr1, index)) in
            let rune2 = load-rune(add-int(ptr2, index)) in
            let offset = core.rune.size(rune1) in
            if core.rune.entity.as-entity::identity(rune1, rune2) {
              let Pos of {row, column} = _get-new-pos(rune1, row, column) in
              consumer(add-int(index, offset), row, column)
            } else {
              Fail(function () {
                _Error of {
                  found = Range(base-offset, add-int(index, offset), stream),
                  expected = [Text-N(t)],
                  position = Pos(*orig-row, *orig-column),
                }
              })
            }
          }
        }
      in
      f(0, *orig-row, *orig-column)
    }
  }
}

inline take-while(p: (rune) -> bool): parser(text) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let len = core.text.text-byte-length(stream) in
    if eq-int(len, 0) {
      Pass(*stream)
    } else {
      let ptr1 = _get-content-pointer(stream) in
      let f =
        define consumer(index: int, row: int, column: int): text {
          let r = load-rune(add-int(ptr1, index)) in
          if p(r) {
            let offset = core.rune.size(r) in
            let Pos of {row, column} = _get-new-pos(r, row, column) in
            consumer(add-int(index, offset), row, column)
          } else {
            let result = _take-N(index, stream) in
            _proceed(st-ref, index, Pos of {row, column});
            result
          }
        }
      in
      Pass(f(0, *row, *column))
    }
  }
}

inline drop-while(p: (rune) -> bool): parser(unit) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let len = core.text.text-byte-length(stream) in
    if eq-int(len, 0) {
      Pass(Unit)
    } else {
      let ptr1 = _get-content-pointer(stream) in
      let f =
        define consumer(index: int, row: int, column: int): unit {
          let r = load-rune(add-int(ptr1, index)) in
          if p(r) {
            let offset = core.rune.size(r) in
            let Pos of {row, column} = _get-new-pos(r, row, column) in
            consumer(add-int(index, offset), row, column)
          } else {
            _proceed(st-ref, index, Pos of {row, column});
            Unit
          }
        }
      in
      f(0, *row, *column);
      Pass(Unit)
    }
  }
}

constant ascii-space: parser(unit) {
  drop-while(
    function (r) {
      if core.rune.entity.as-entity::identity(r, 0x20) {
        True
      } else-if ule-int32(sub-int32(r, 0x9), 0x4) {
        True
      } else {
        False
      }
    },
  )
}

inline with-label<a>(label: &text, p: parser(a)): parser(a) {
  function (st-ref: &cell(state)) {
    tie State of {stream} = _read(st-ref) in
    let base-offset = _load-text-offset(stream) in
    match p(st-ref) {
    | Pass(result) =>
      Pass(result)
    | Fail(e) =>
      let new-offset = _load-text-offset(stream) in
      if eq-int(base-offset, new-offset) {
        Fail(set-expected(Label(*label), e))
      } else {
        Fail(e)
      }
    }
  }
}

inline attempt<a>(p: parser(a)): parser(a) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let base-offset = _load-text-offset(stream) in
    match p(st-ref) {
    | Pass(result) =>
      Pass(result)
    | Fail(e) =>
      mutate(st-ref, _rewind-state(base-offset, *row, *column));
      Fail(e)
    }
  }
}

inline look-ahead<a>(p: parser(a)): parser(a) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let base-offset = _load-text-offset(stream) in
    match p(st-ref) {
    | Pass(result) =>
      mutate(st-ref, _rewind-state(base-offset, *row, *column));
      Pass(result)
    | Fail(e) =>
      Fail(e)
    }
  }
}

inline not-followed-by<a>(p: parser(a)): parser(unit) {
  function (st-ref: &cell(state)) {
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st-ref) in
    let base-offset = _load-text-offset(stream) in
    match p(st-ref) {
    | Pass(_) =>
      mutate(st-ref, _rewind-state(base-offset, *row, *column));
      let head-char = take-N(1, stream) in
      let b on head-char = is-empty(head-char) in
      if b {
        Fail(unexpected-end-of-input(Pos(*row, *column)))
      } else {
        Fail(function () {
          _Error of {
            found = Text(head-char),
            expected = [],
            position = Pos(*row, *column),
          }
        })
      }
    | Fail(_) =>
      mutate(st-ref, _rewind-state(base-offset, *row, *column));
      Pass(Unit)
    }
  }
}

define _choose<a>(
  candidates: list(parser(a)),
  fallback: parser(a),
  error-cand: error,
): parser(a) {
  function (st-ref: &cell(state)) {
    tie State of {stream} = _read(st-ref) in
    let old-offset = _load-text-offset(stream) in
    match candidates {
    | Nil =>
      match fallback(st-ref) {
      | Pass(v) =>
        Pass(v)
      | Fail(e) =>
        let new-offset = _load-text-offset(stream) in
        if eq-int(old-offset, new-offset) {
          Fail(join(error-cand, e))
        } else {
          Fail(e)
        }
      }
    | Cons(cand, rest) =>
      match cand(st-ref) {
      | Pass(v) =>
        Pass(v)
      | Fail(e) =>
        let new-offset = _load-text-offset(stream) in
        if eq-int(old-offset, new-offset) {
          _choose(rest, fallback, join(error-cand, e))(st-ref)
        } else {
          Fail(e)
        }
      }
    }
  }
}

inline choose<a>(candidates: list(parser(a)), fallback: parser(a)): parser(a) {
  match candidates {
  | Nil =>
    fallback
  | Cons(p, rest) =>
    function (st-ref) {
      tie State of {stream} = _read(st-ref) in
      let old-offset = _load-text-offset(stream) in
      match p(st-ref) {
      | Pass(v) =>
        Pass(v)
      | Fail(e) =>
        let new-offset = _load-text-offset(stream) in
        if eq-int(old-offset, new-offset) {
          _choose(rest, fallback, e)(st-ref)
        } else {
          Fail(e)
        }
      }
    }
  }
}

inline many<a>(p: parser(a)): parser(list(a)) {
  define self(st-ref: &cell(state)) {
    match p(st-ref) {
    | Pass(v) =>
      try vs = self(st-ref) in
      Pass(Cons(v, vs))
    | Fail(_) =>
      Pass([])
    }
  }
}

inline some<a>(p: parser(a)): parser(list(a)) {
  function (st-ref: &cell(state)) {
    try v = p(st-ref) in
    try vs = many(p)(st-ref) in
    Pass(Cons(v, vs))
  }
}

define _try-parse(my-parser: parser(unit)): unit {
  let st = new-state(*"abcnああhehoge \n\r  hehehetest") in
  let _ on st =
    let _ = chunk("abc")(st) in
    let result = my-parser(st) in
    tie State of {stream, lastpos = Pos of {row, column}} = _read(st) in
    match result {
    | Pass(_) =>
      print("remaining text: ");
      print(stream);
      print("\n");
      printf("0-indexed cursor position: ({}, {})\n", [%ld(*row), %ld(*column)]);
      let _ = st in
      print("pass!\n")
    | Fail(e) =>
      let _ = e in
      Unit
    }
  in
  let _ = st in
  Unit
}

define noa-test(): unit {
  noa::check(
    "chunk(t1) against append(t1, t2) must succeed and the remaining text is t2",
    pairs(texts, texts),
    function (p) {
      let Pair(t1, t2) = p in
      let full-text on t1, t2 = core.text.append(t1, t2) in
      let st = new-state(full-text) in
      let parse-result on t1, t2, st =
        let p = chunk(t1) in
        let parse-result = p(st) in
        match parse-result {
        | Pass(_) =>
          let result =
            tie State of {stream} = _read(st) in
            core.text.entity.as-entity::identity(t2, stream)
          in
          result
        | Fail(_) =>
          False
        }
      in
      let _ = t1 in
      let _ = t2 in
      let _ = st in
      parse-result
    },
  );
  noa::check(
    "`t1` can be parsed by (chunk(t1) → end-of-input)",
    texts,
    function (t) {
      let st = new-state(t) in
      let parse-result on t, st =
        let p = chunk(t) in
        match p(st) {
        | Pass(_) =>
          match end-of-input(st) {
          | Pass(_) =>
            True
          | Fail(_) =>
            False
          }
        | Fail(_) =>
          False
        }
      in
      let _ = t in
      let _ = st in
      parse-result
    },
  );
  noa::check(
    "`append(t1, t2)` can be parsed by `chunk(t1) → chunk(t2) → end-of-input`",
    pairs(texts, texts),
    function (p) {
      let Pair(t1, t2) = p in
      let full-text on t1, t2 = core.text.append(t1, t2) in
      let st = new-state(full-text) in
      let result on t1, t2, st =
        let _ = chunk(t1)(st) in
        let _ = chunk(t2)(st) in
        let parse-result = end-of-input(st) in
        match parse-result {
        | Pass(_) =>
          True
        | Fail(_) =>
          False
        }
      in
      let _ = t1 in
      let _ = t2 in
      let _ = st in
      result
    },
  );
  noa::check(
    "for any non-empty text, end-of-input must fail",
    texts,
    function (t) {
      let len on t = text-byte-length(t) in
      if eq-int(len, 0) {
        True
      } else {
        let st = new-state(t) in
        let result on st =
          let p = end-of-input in
          let parse-result = p(st) in
          match parse-result {
          | Pass(_) =>
            False
          | Fail(_) =>
            True
          }
        in
        let _ = st in
        result
      }
    },
  )
}

define zen(): unit {
  let my-parser =
    choose of {
      candidates = {
        [
          chunk("gaoe"),
          choose([chunk("k")], with-label("whatever", function (st) {
            try _ = chunk("p")(st) in
            try _ = chunk("kgあ")(st) in
            Pass(Unit)
          })),
          chunk("tあい"),
          with-label("whatever 2", function (st) {
            try _ = chunk("pt")(st) in
            try _ = chunk("あhebc")(st) in
            Pass(Unit)
          }),
          function (st) {
            try _ = chunk("pt")(st) in
            try _ = chunk("あhebc")(st) in
            Pass(Unit)
          },
          chunk("abc"),
          chunk("{}"),
        ]
      },
      fallback = chunk("tk"),
    }
  in
  loop(1000000, Unit, function (_, _) {
    _try-parse(my-parser)
  });
  // let st = new-state(*"ab\nctああhehoge \n\r  hehehetest") in
  // let _ on st =
  //   let _ = chunk("ab\nc")(st) in
  //   let result = my-parser(st) in
  //   tie State of {stream, lastpos = Pos of {row, column}} = _read(st) in
  //   match result {
  //   | Pass(_) =>
  //     print("remaining text: ");
  //     print(stream);
  //     print("\n");
  //     printf("0-indexed cursor position: ({}, {})\n", [%ld(*row), %ld(*column)]);
  //     let _ = st in
  //     print("pass!\n")
  //   | Fail(e) =>
  //     printf("{}\n", [report(e)])
  //   }
  // in
  // let _ = st in
  Unit
}
