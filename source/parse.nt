import {
  core.int.io {print-int-line},
  core.pointer {shift},
  core.rune {load-rune},
  core.text {_get-content-pointer, _get-rune, _slice-N},
  core.text.io {print-line},
  this.error {report},
  this.expected-item {_Label, _Raw-Text, expected-item},
  this.make-parse-error {make-parse-error},
  this.make-zonk-kit {make-zonk-kit},
  this.point {Point, point},
  this.private.state {
    _export-state,
    _get-column,
    _get-cursor,
    _get-gap-size,
    _get-line,
    _import-state,
    _proceed-by-rune,
    _set-gap-size,
    _set-new-position,
  },
  this.zonk-kit {_Zonk-Kit, position, zonk-kit},
}

inline parsed(a): type {
  either(expected-item, a)
}

inline zonk(a) {
  (&zonk-kit) -> parsed(a)
}

inline report-unexpected-input<a>(label: &text): parsed(a) {
  Left(_Label(label))
}

inline get-point(k: &zonk-kit): point {
  let line = _get-line(k);
  let column = _get-column(k);
  Point(line, column)
}

define end-of-input: zonk(unit) {
  function (k) {
    tie _Zonk-Kit of {input-stream} = k;
    let cursor = _get-cursor(k);
    let len = core.text.text-byte-length(input-stream);
    if ge-int(cursor, len) {
      Right(Unit)
    } else {
      _set-gap-size(k, 1);
      Left(_Label("end of input"))
    }
  }
}

inline satisfy(label: &text, p: (rune) -> bool): zonk(rune) {
  function (k) {
    tie _Zonk-Kit of {input-stream} = k;
    let len = core.text.text-byte-length(input-stream);
    let cursor = _get-cursor(k);
    if ge-int(cursor, len) {
      Left(_Label(label))
    } else {
      let r = _get-rune(input-stream, cursor);
      if p(r) {
        _proceed-by-rune(k, r);
        Right(r)
      } else {
        _set-gap-size(k, 1);
        Left(_Label(label))
      }
    }
  }
}

inline any-rune: zonk(rune) {
  satisfy("any character", function (_) {
    True
  })
}

define _chunk-body(k: &zonk-kit, chunk-text: &text): int {
  tie _Zonk-Kit of {input-stream} = k;
  let cursor = _get-cursor(k);
  let len1 = core.text.text-byte-length(input-stream);
  let len2 = core.text.text-byte-length(chunk-text);
  if lt-int(len1, len2) {
    -1
  } else {
    let ptr1 = shift(_get-content-pointer(input-stream), cursor);
    let ptr2 = _get-content-pointer(chunk-text);
    let chunk-len = core.text.length(chunk-text);
    let f =
      define _chunk-consumer(
        index: int,
        line: int,
        column: int,
      ): int {
        if eq-int(index, len2) {
          _set-new-position(k, add-int(cursor, len2), line, column);
          1
        } else {
          let rune1 = load-rune(shift(ptr1, index));
          let rune2 = load-rune(shift(ptr2, index));
          let offset = core.rune.size(rune1);
          if eq-rune(rune1, rune2) {
            if eq-rune(rune1, `\n`) {
              _chunk-consumer(add-int(index, offset), add-int(line, 1), 0)
            } else {
              _chunk-consumer(add-int(index, offset), line, add-int(column, 1))
            }
          } else {
            _set-gap-size(k, chunk-len);
            -1
          }
        }
      };
    let line = _get-line(k);
    let column = _get-column(k);
    f(0, line, column)
  }
}

inline chunk(chunk-text: &text): zonk(unit) {
  function (k) {
    let result-flag = _chunk-body(k, chunk-text);
    if gt-int(result-flag, 0) {
      Right(Unit)
    } else {
      Left(_Raw-Text(chunk-text))
    }
  }
}

inline take-while(!p: (rune) -> bool): zonk(text) {
  function (k) {
    tie _Zonk-Kit of {input-stream} = k;
    let len = core.text.text-byte-length(input-stream);
    let cursor = _get-cursor(k);
    let orig-cursor = cursor;
    let ptr1 = _get-content-pointer(input-stream);
    let f =
      define consumer(cursor: int, line: int, column: int): text {
        let is-tail = ge-int(cursor, len);
        if is-tail {
          _set-new-position(k, cursor, line, column);
          _slice-N(input-stream, orig-cursor, sub-int(cursor, orig-cursor))
        } else {
          let r = load-rune(shift(ptr1, cursor));
          if !p(r) {
            let offset = core.rune.size(r);
            if eq-rune(r, `\n`) {
              consumer(add-int(cursor, offset), add-int(line, 1), 0)
            } else {
              consumer(add-int(cursor, offset), line, add-int(column, 1))
            }
          } else {
            _set-new-position(k, cursor, line, column);
            _slice-N(input-stream, orig-cursor, sub-int(cursor, orig-cursor))
          }
        }
      };
    let cursor = _get-cursor(k);
    let Point(line, column) = get-point(k);
    Right(f(cursor, line, column))
  }
}

inline take-while-1(!p: (rune) -> bool): zonk(text) {
  function (k) {
    tie _Zonk-Kit of {input-stream} = k;
    let len = core.text.text-byte-length(input-stream);
    let cursor = _get-cursor(k);
    let orig-cursor = cursor;
    let ptr1 = _get-content-pointer(input-stream);
    let f =
      define consumer(cursor: int, line: int, column: int): parsed(text) {
        let is-tail = ge-int(cursor, len);
        if is-tail {
          let size = sub-int(cursor, orig-cursor);
          if lt-int(size, 0) {
            _set-new-position(k, cursor, line, column);
            Right(_slice-N(input-stream, orig-cursor, size))
          } else {
            Left(_Label("non-empty string"))
          }
        } else {
          let r = load-rune(shift(ptr1, cursor));
          if !p(r) {
            let offset = core.rune.size(r);
            if eq-rune(r, `\n`) {
              consumer(add-int(cursor, offset), add-int(line, 1), 0)
            } else {
              consumer(add-int(cursor, offset), line, add-int(column, 1))
            }
          } else {
            let size = sub-int(cursor, orig-cursor);
            if lt-int(size, 0) {
              _set-new-position(k, cursor, line, column);
              Right(_slice-N(input-stream, orig-cursor, sub-int(cursor, orig-cursor)))
            } else {
              Left(_Label("non-empty string"))
            }
          }
        }
      };
    let cursor = _get-cursor(k);
    let Point(line, column) = get-point(k);
    f(cursor, line, column)
  }
}

inline drop-while(!p: (rune) -> bool): zonk(unit) {
  function (k) {
    tie _Zonk-Kit of {input-stream} = k;
    let len = core.text.text-byte-length(input-stream);
    let cursor = _get-cursor(k);
    let ptr1 = _get-content-pointer(input-stream);
    let f =
      define consumer(cursor: int, line: int, column: int): unit {
        let is-tail = ge-int(cursor, len);
        if is-tail {
          _set-new-position(k, cursor, line, column);
        } else {
          let r = load-rune(shift(ptr1, cursor));
          if !p(r) {
            let offset = core.rune.size(r);
            if eq-rune(r, `\n`) {
              consumer(add-int(cursor, offset), add-int(line, 1), 0)
            } else {
              consumer(add-int(cursor, offset), line, add-int(column, 1))
            }
          } else {
            _set-new-position(k, cursor, line, column);
          }
        }
      };
    let line = _get-line(k);
    let column = _get-column(k);
    Right(f(cursor, line, column))
  }
}

inline ascii-space: zonk(unit) {
  drop-while(
    function (r) {
      if eq-rune(r, ` `) {
        True
      } else-if ule-int32(sub-int32(magic cast(rune, int32, r), 0x9), 0x4) {
        True
      } else {
        False
      }
    },
  )
}

inline label<a>(l: &text, p: zonk(a)): zonk(a) {
  function (k) {
    let v = p(k);
    match v {
    | Right(result) =>
      Right(result)
    | Left(_) =>
      Left(_Label(l))
    }
  }
}

define _attempt-body<a>(k: &zonk-kit, state-pack: position, v: parsed(a)): parsed(a) {
  match v {
  | Right(result) =>
    Right(result)
  | Left(e) =>
    _import-state(k, state-pack);
    Left(e)
  }
}

inline attempt<a>(p: zonk(a)): zonk(a) {
  function (k) {
    let state-pack = _export-state(k);
    _attempt-body(k, state-pack, p(k))
  }
}

define _look-ahead-body<a>(k: &zonk-kit, state-pack: position, v: parsed(a)): parsed(a) {
  match v {
  | Right(result) =>
    _import-state(k, state-pack);
    Right(result)
  | Left(e) =>
    Left(e)
  }
}

inline look-ahead<a>(p: zonk(a)): zonk(a) {
  function (k) {
    let state-pack = _export-state(k);
    _look-ahead-body(k, state-pack, p(k))
  }
}

define _optional-body<a>(v: parsed(a)): parsed(?a) {
  match v {
  | Right(result) =>
    Right(Right(result))
  | Left(_) =>
    Right(Left(Unit))
  }
}

inline optional<a>(p: zonk(a)): zonk(?a) {
  function (k) {
    _optional-body(p(k))
  }
}

inline branch<a>(p1: zonk(a), p2: zonk(a)): zonk(a) {
  function (k) {
    match p1(k) {
    | Right(result) =>
      Right(result)
    | Left(_) =>
      p2(k)
    }
  }
}

define _not-followed-by-body<a>(
  k: &zonk-kit,
  state-pack: position,
  v: parsed(a),
): bool {
  _import-state(k, state-pack);
  match v {
  | Left(_) =>
    True
  | Right(_) =>
    _set-gap-size(k, 1);
    False
  }
}

inline not-followed-by<a>(label: &text, p: zonk(a)): zonk(unit) {
  function (k) {
    let state-pack = _export-state(k);
    let result = _not-followed-by-body(k, state-pack, p(k));
    if result {
      Right(Unit)
    } else {
      Left(_Label(label))
    }
  }
}

define _choice<a>(
  k: &zonk-kit,
  label: &text,
  candidates: list(zonk(a)),
  fallback: zonk(a),
  default-gap-size: int,
): parsed(a) {
  match candidates {
  | Nil =>
    match fallback(k) {
    | Right(v) =>
      _set-gap-size(k, default-gap-size);
      Right(v)
    | Left(_) =>
      Left(_Label(label))
    }
  | Cons(cand, rest) =>
    match cand(k) {
    | Right(v) =>
      _set-gap-size(k, default-gap-size);
      Right(v)
    | Left(_) =>
      _choice(k, label, rest, fallback, default-gap-size)
    }
  }
}

inline choice<a>(label: &text, candidates: list(zonk(a)), fallback: zonk(a)): zonk(a) {
  function (k) {
    match candidates {
    | Nil =>
      fallback(k)
    | Cons(p, rest) =>
      let old-offset = _get-cursor(k);
      match p(k) {
      | Right(v) =>
        Right(v)
      | Left(e) =>
        let new-offset = _get-cursor(k);
        if eq-int(old-offset, new-offset) {
          let gap-size = _get-gap-size(k);
          _choice(k, label, rest, fallback, gap-size)
        } else {
          Left(e)
        }
      }
    }
  }
}

inline many<a>(!p: zonk(a)): zonk(list(a)) {
  function (k) {
    let f =
      define self(): parsed(list(a)) {
        match !p(k) {
        | Right(v) =>
          try vs = self();
          Right(Cons(v, vs))
        | Left(_) =>
          Right(Nil)
        }
      };
    f()
  }
}

inline some<a>(!p: zonk(a)): zonk(list(a)) {
  function (k) {
    try v = !p(k);
    try vs = many(!p)(k);
    Right(Cons(v, vs))
  }
}

define zen(): unit {
  let my-parser =
    choice(
      "some term",
      List[
        function (k) {
          try _ = chunk("gaoe")(k);
          try _ = chunk("item")(k);
          Right(Unit)
        },
        choice("item", List[chunk("k")], label("whatever", function (k) {
          try _ = chunk("px")(k);
          try _ = chunk("kgあ")(k);
          Right(Unit)
        })),
        chunk("tあい"),
        label("whatever 2", function (k) {
          try _ = chunk("pt")(k);
          try _ = chunk("あhebc")(k);
          Right(Unit)
        }),
        chunk("abc"),
        chunk("{}"),
        end-of-input,
      ],
      chunk("tn"),
    );
  pin k = make-zonk-kit(*"gaxoeitemtesttnapqabcd\nctああhehoge \n\r  hehehetest");
  let my-result = my-parser(k);
  match my-result {
  | Left(e) =>
    let e' = make-parse-error(k, e);
    pin e'' = report(e');
    print("left: ");
    print-line(e'');
  | Right(_) =>
    print("right\n")
  }
}
