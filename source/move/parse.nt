import {
  core.cell {borrow, mutate},
  core.magic,
  core.memory {load-int},
  core.pointer {shift},
  core.rune {load-rune},
  core.text {_drop-N, _get-content-pointer, _get-rune, _slice-N, is-empty, take-N},
  core.text.show {show-text},
  this.move.make-zonk-kit {make-zonk-kit},
  this.rule.error {Parse-Error, report},
  this.rule.point {Point, point},
  this.rule.stash {
    _Stash,
    _empty-stash,
    _join-stash,
    _set-expected,
    _stash,
  },
  this.rule.tag {Label, Raw-Text, tag},
  this.rule.zonk-kit {_Position, _Zonk-Kit, position, zonk-kit},
}

inline zonk(a) {
  (&zonk-kit) -> either(_stash, a)
}

inline _get-offset(r: rune): point {
  if eq-rune(r, `\n`) {
    Point of {row = 1, column = 0}
  } else {
    Point of {row = 0, column = 1}
  }
}

inline _set-gap-spot(k: &zonk-kit, gap-spot: int): unit {
  tie _Zonk-Kit of {position-ref} = k in
  mutate(position-ref, function (position) {
    let _Position of {cursor, line, column} = position in
    _Position of {cursor, line, column, gap-spot}
  })
}

define _trick-read<a>(ch: &cell(a)): &a {
  let ch = core.magic.cast(&cell(a), pointer, ch) in
  let val-base = load-int(ch) in
  core.magic.cast(int, &a, val-base)
}

define _get-cursor(k: &zonk-kit): int {
  tie _Zonk-Kit of {position-ref} = k in
  let position = _trick-read(position-ref) in
  tie _Position of {cursor} = position in
  *cursor
}

define _get-gap-spot(k: &zonk-kit): int {
  tie _Zonk-Kit of {position-ref} = k in
  borrow(position-ref, function (position) {
    tie _Position of {gap-spot} = position in
    quote {*gap-spot}
  })
}

define _get-line(k: &zonk-kit): int {
  tie _Zonk-Kit of {position-ref} = k in
  borrow(position-ref, function (position) {
    tie _Position of {line} = position in
    quote {*line}
  })
}

define _get-column(k: &zonk-kit): int {
  tie _Zonk-Kit of {position-ref} = k in
  borrow(position-ref, function (position) {
    tie _Position of {column} = position in
    quote {*column}
  })
}

inline _proceed(k: &zonk-kit, byte-offset: int, line-offset: int, column-offset: int): unit {
  tie _Zonk-Kit of {position-ref} = k in
  mutate(position-ref, function (position) {
    let _Position of {cursor, line, column, gap-spot} = position in
    let cursor = add-int(cursor, byte-offset) in
    let line = add-int(line, line-offset) in
    let column = add-int(column, column-offset) in
    _Position of {cursor, line, column, gap-spot}
  })
}

inline _proceed-by-rune(k: &zonk-kit, r: rune): unit {
  if eq-rune(r, `\n`) {
    _proceed of {k, byte-offset = 1, line-offset = 1, column-offset = 0}
  } else {
    let byte-offset = core.rune.size(r) in
    _proceed of {k, byte-offset, line-offset = 0, column-offset = 1}
  }
}

inline _export-state(k: &zonk-kit): position {
  tie _Zonk-Kit of {position-ref} = k in
  core.cell.clone(position-ref)
}

inline _import-state(k: &zonk-kit, new-position: position): unit {
  tie _Zonk-Kit of {position-ref} = k in
  mutate(position-ref, function (old-position) {
    let _Position of {} = old-position in
    new-position
  })
}

define report-unexpected-input<a>(expected-item-label: &text): either(_stash, a) {
  Left(_Stash(function () {
    [Label(expected-item-label)]
  }))
}

define get-point(k: &zonk-kit): point {
  let line = _get-line(k) in
  let column = _get-column(k) in
  Point(line, column)
}

define fail<a>(expected: list(tag)): either(_stash, a) {
  Left(_Stash of {
    expected = {
      function () {
        expected
      }
    },
  })
}

define end-of-input: zonk(unit) {
  function (k) {
    tie _Zonk-Kit of {input-stream} = k in
    let cursor = _get-cursor(k) in
    let len = core.text.text-byte-length(input-stream) in
    if ge-int(cursor, len) {
      Right(Unit)
    } else {
      _set-gap-spot(k, 1);
      Left(_Stash of {
        expected = {
          function () {
            [Label("end of input")]
          }
        },
      })
    }
  }
}

inline satisfy(p: (rune) -> bool): zonk(rune) {
  function (k) {
    tie _Zonk-Kit of {input-stream} = k in
    let len = core.text.text-byte-length(input-stream) in
    let cursor = _get-cursor(k) in
    if ge-int(cursor, len) {
      Left(_empty-stash)
    } else {
      let r = _get-rune(input-stream, cursor) in
      if p(r) {
        _proceed-by-rune(k, r);
        Right(r)
      } else {
        _set-gap-spot(k, 1);
        Left(_Stash of {
          expected = {
            function () {
              []
            }
          },
        })
      }
    }
  }
}

inline any-rune: zonk(rune) {
  satisfy(function (_) {
    True
  })
}

inline _chunk-body(k: &zonk-kit, chunk-text: &text): either(_stash, unit) {
  tie _Zonk-Kit of {input-stream} = k in
  let cursor = _get-cursor(k) in
  let len1 = core.text.text-byte-length(input-stream) in
  let len2 = core.text.text-byte-length(chunk-text) in
  if lt-int(len1, len2) {
    Left(_empty-stash)
  } else {
    let ptr1 = shift(_get-content-pointer(input-stream), cursor) in
    let ptr2 = _get-content-pointer(chunk-text) in
    let f =
      define _chunk-consumer(
        index: int,
        char-len: int,
        line-offset: int,
        column-offset: int,
      ): either(_stash, unit) {
        if eq-int(index, len2) {
          _proceed(k, len2, line-offset, column-offset);
          Right(Unit)
        } else {
          let rune1 = load-rune(shift(ptr1, index)) in
          let rune2 = load-rune(shift(ptr2, index)) in
          let offset = core.rune.size(rune1) in
          if eq-rune(rune1, rune2) {
            let b = eq-rune(rune1, `\n`) in
            let l = match b {True => 1 | False => 0} in
            let c = match b {True => 0 | False => 1} in
            _chunk-consumer(
              add-int(index, offset),
              add-int(char-len, 1),
              add-int(line-offset, l),
              add-int(column-offset, c),
            )
          } else {
            _set-gap-spot(k, add-int(char-len, 1));
            Left(_Stash of {
              expected = {
                function () {
                  [Raw-Text(chunk-text)]
                }
              },
            })
          }
        }
      }
    in
    f(0, 0, 0, 0)
  }
}

inline chunk(chunk-text: &text): zonk(unit) {
  function (k) {
    _chunk-body(k, chunk-text)
  }
}

inline take-while(!p: (rune) -> bool): zonk(text) {
  function (k) {
    tie _Zonk-Kit of {input-stream} = k in
    let len = core.text.text-byte-length(input-stream) in
    let cursor = _get-cursor(k) in
    let ptr1 = _get-content-pointer(input-stream) in
    let f =
      define consumer(cursor-offset: int, line-offset: int, column-offset: int): text {
        let is-tail = ge-int(add-int(cursor, cursor-offset), len) in
        if is-tail {
          _proceed(k, cursor-offset, line-offset, column-offset);
          _slice-N(input-stream, cursor, cursor-offset)
        } else {
          let r = load-rune(shift(ptr1, add-int(cursor, cursor-offset))) in
          if !p(r) {
            let offset = core.rune.size(r) in
            let Point(l, c) = _get-offset(r) in
            consumer(add-int(cursor-offset, offset), add-int(line-offset, l), add-int(column-offset, c))
          } else {
            _proceed(k, cursor-offset, line-offset, column-offset);
            _slice-N(input-stream, cursor, cursor-offset)
          }
        }
      }
    in
    Right(f(0, 0, 0))
  }
}

inline drop-while(!p: (rune) -> bool): zonk(unit) {
  function (k) {
    tie _Zonk-Kit of {input-stream} = k in
    let len = core.text.text-byte-length(input-stream) in
    let cursor = _get-cursor(k) in
    let ptr1 = _get-content-pointer(input-stream) in
    let f =
      define consumer(cursor-offset: int, line-offset: int, column-offset: int): unit {
        let is-tail = ge-int(add-int(cursor, cursor-offset), len) in
        if is-tail {
          _proceed(k, cursor-offset, line-offset, column-offset)
        } else {
          let r = load-rune(shift(ptr1, add-int(cursor, cursor-offset))) in
          if !p(r) {
            let offset = core.rune.size(r) in
            let Point(l, c) = _get-offset(r) in
            consumer(add-int(cursor-offset, offset), add-int(line-offset, l), add-int(column-offset, c))
          } else {
            _proceed(k, cursor-offset, line-offset, column-offset)
          }
        }
      }
    in
    Right(f(0, 0, 0))
  }
}

inline ascii-space: zonk(unit) {
  drop-while(
    function (r) {
      if eq-rune(r, ` `) {
        True
      } else-if ule-int32(sub-int32(magic cast(rune, int32, r), 0x9), 0x4) {
        True
      } else {
        False
      }
    },
  )
}

define _label-body<a>(k: &zonk-kit, l: &text, orig-cursor: int, v: either(_stash, a)): either(_stash, a) {
  match v {
  | Right(result) =>
    Right(result)
  | Left(e) =>
    let new-cursor = _get-cursor(k) in
    if eq-int(orig-cursor, new-cursor) {
      Left(_set-expected(
        function () {
          [Label(l)]
        },
        e,
      ))
    } else {
      Left(e)
    }
  }
}

inline label<a>(l: &text, p: zonk(a)): zonk(a) {
  function (k) {
    let orig-cursor = _get-cursor(k) in
    let v = p(k) in
    _label-body(k, l, orig-cursor, v)
  }
}

define _hidden-body<a>(v: either(_stash, a)): either(_stash, a) {
  match v {
  | Right(result) =>
    Right(result)
  | Left(e) =>
    Left(_set-expected(
      function () {
        []
      },
      e,
    ))
  }
}

inline hidden<a>(p: zonk(a)): zonk(a) {
  function (k) {
    let v = p(k) in
    _hidden-body(v)
  }
}

define _attempt-body<a>(k: &zonk-kit, state-pack: position, v: either(_stash, a)): either(_stash, a) {
  match v {
  | Right(result) =>
    Right(result)
  | Left(e) =>
    _import-state(k, state-pack);
    Left(e)
  }
}

inline attempt<a>(p: zonk(a)): zonk(a) {
  function (k) {
    let state-pack = _export-state(k) in
    _attempt-body(k, state-pack, p(k))
  }
}

define _look-ahead-body<a>(k: &zonk-kit, state-pack: position, v: either(_stash, a)): either(_stash, a) {
  match v {
  | Right(result) =>
    _import-state(k, state-pack);
    Right(result)
  | Left(e) =>
    Left(e)
  }
}

inline look-ahead<a>(p: zonk(a)): zonk(a) {
  function (k) {
    let state-pack = _export-state(k) in
    _look-ahead-body(k, state-pack, p(k))
  }
}

define _optional-body<a>(v: either(_stash, a)): either(_stash, ?a) {
  match v {
  | Right(result) =>
    Right(Right(result))
  | Left(_) =>
    Right(Left(Unit))
  }
}

inline optional<a>(p: zonk(a)): zonk(?a) {
  function (k) {
    _optional-body(p(k))
  }
}

inline branch<a>(p1: zonk(a), p2: zonk(a)): zonk(a) {
  function (k) {
    match p1(k) {
    | Right(result) =>
      Right(result)
    | Left(_) =>
      p2(k)
    }
  }
}

define _not-followed-by-body<a>(k: &zonk-kit, state-pack: position, v: either(_stash, a)): either(_stash, unit) {
  _import-state(k, state-pack);
  match v {
  | Right(_) =>
    tie _Zonk-Kit of {input-stream} = k in
    let head-char = take-N(input-stream, 1) in
    let b on head-char = is-empty(head-char) in
    let _ = head-char in
    if b {
      Left(_empty-stash)
    } else {
      _set-gap-spot(k, 1);
      Left(_Stash of {
        expected = {
          function () {
            []
          }
        },
      })
    }
  | Left(_) =>
    Right(Unit)
  }
}

inline not-followed-by<a>(p: zonk(a)): zonk(unit) {
  function (k) {
    let state-pack = _export-state(k) in
    _not-followed-by-body(k, state-pack, p(k))
  }
}

define _choice<a>(
  k: &zonk-kit,
  candidates: list(zonk(a)),
  fallback: zonk(a),
  stash-cand: _stash,
  default-gap-spot: int,
): either(_stash, a) {
  let old-offset = _get-cursor(k) in
  match candidates {
  | Nil =>
    match fallback(k) {
    | Right(v) =>
      _set-gap-spot(k, default-gap-spot);
      Right(v)
    | Left(e) =>
      let new-offset = _get-cursor(k) in
      if eq-int(old-offset, new-offset) {
        Left(_join-stash(stash-cand, e))
      } else {
        Left(e)
      }
    }
  | Cons(cand, rest) =>
    match cand(k) {
    | Right(v) =>
      _set-gap-spot(k, default-gap-spot);
      Right(v)
    | Left(e) =>
      let new-offset = _get-cursor(k) in
      if eq-int(old-offset, new-offset) {
        _choice(k, rest, fallback, _join-stash(stash-cand, e), default-gap-spot)
      } else {
        Left(e)
      }
    }
  }
}

inline choice<a>(candidates: list(zonk(a)), fallback: zonk(a)): zonk(a) {
  function (k) {
    match candidates {
    | Nil =>
      fallback(k)
    | Cons(p, rest) =>
      let old-offset = _get-cursor(k) in
      match p(k) {
      | Right(v) =>
        Right(v)
      | Left(e) =>
        let new-offset = _get-cursor(k) in
        if eq-int(old-offset, new-offset) {
          let gap-spot = _get-gap-spot(k) in
          _choice(k, rest, fallback, e, gap-spot)
        } else {
          Left(e)
        }
      }
    }
  }
}

inline many<a>(!p: zonk(a)): zonk(list(a)) {
  function (k) {
    let f =
      define self(): either(_stash, list(a)) {
        match !p(k) {
        | Right(v) =>
          try vs = self() in
          Right(Cons(v, vs))
        | Left(_) =>
          Right([])
        }
      }
    in
    f()
  }
}

inline some<a>(!p: zonk(a)): zonk(list(a)) {
  function (k) {
    try v = !p(k) in
    try vs = many(!p)(k) in
    Right(Cons(v, vs))
  }
}

define zen(): unit {
  let my-parser =
    choice(
      [
        function (k) {
          try _ = chunk("gaoe")(k) in
          try _ = chunk("item")(k) in
          Right(Unit)
        },
        choice([chunk("k")], label("whatever", function (k) {
          try _ = chunk("px")(k) in
          try _ = chunk("kgあ")(k) in
          Right(Unit)
        })),
        chunk("tあい"),
        label("whatever 2", function (k) {
          try _ = chunk("pt")(k) in
          try _ = chunk("あhebc")(k) in
          Right(Unit)
        }),
        chunk("abc"),
        chunk("{}"),
        end-of-input,
      ],
      chunk("tn"),
    )
  in
  pin k = make-zonk-kit(*"gaoeiteemtesttnapqabcd\nctああhehoge \n\r  hehehetest") in
  let my-result = my-parser(k) in
  match my-result {
  | Left(e) =>
    tie _Zonk-Kit of {input-stream} = k in
    let cursor = _get-cursor(k) in
    let line = _get-line(k) in
    let column = _get-column(k) in
    let gap-spot = _get-gap-spot(k) in
    let _Stash of {expected} = e in
    pin foo = _drop-N(input-stream, cursor) in
    let e' =
      Parse-Error of {
        expected = expected(),
        found = show-text(take-N(foo, gap-spot)),
        error-location = Point(line, column),
      }
    in
    printf("left: {}\n", [report(e')])
  | Right(_) =>
    print("right\n")
  }
}
